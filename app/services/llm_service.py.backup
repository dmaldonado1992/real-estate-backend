"""
Servicio LLM para b√∫squeda inteligente de propiedades usando Ollama Cloud.
"""
from typing import List
import os
import json
import re
import aiohttp
import asyncio
from datetime import datetime, timedelta


class LLMService:
    def __init__(self, model_name: str = "llama-3.1-sonar-small-128k-online"):
        self.model_name = model_name
        self.provider = "ollama_cloud"  # Usar Ollama en la nube
        self.base_url = "https://api.ollama.ai"  # URL de Ollama Cloud
        self.api_key = os.getenv("OLLAMA_API_KEY", "")
        print(f"LLMService: Usando Ollama Cloud con modelo {model_name}")

    async def test_connection(self) -> bool:
        """Verificar conexi√≥n con Ollama Cloud."""
        if not self.api_key:
            print("‚ùå No se encontr√≥ OLLAMA_API_KEY")
            return False
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                }
                # Test simple para verificar la API de Ollama Cloud
                payload = {
                    "model": self.model_name,
                    "messages": [{"role": "user", "content": "test"}],
                    "max_tokens": 10
                }
                async with session.post(
                    f"{self.base_url}/chat/completions", 
                    json=payload,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    return response.status == 200
        except Exception as e:
            print(f"‚ùå Error verificando Ollama Cloud: {e}")
            return False

    async def _call_perplexity_cloud(self, prompt: str, system_prompt: str = None) -> str:
        """Llamar a Ollama Cloud API con el modelo Perplexity."""
        try:
            if not self.api_key:
                print("‚ùå OLLAMA_API_KEY no configurada")
                return ""

            messages = []
            if system_prompt:
                messages.append({"role": "system", "content": system_prompt})
            messages.append({"role": "user", "content": prompt})

            payload = {
                "model": self.model_name,  # Modelo Perplexity en Ollama Cloud
                "messages": messages,
                "max_tokens": 1000,
                "temperature": 0.1,  # M√°s determin√≠stico para JSON
                "top_p": 0.9
            }
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{self.base_url}/chat/completions", 
                    json=payload,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        content = result.get("choices", [{}])[0].get("message", {}).get("content", "")
                        return content.strip()
                    else:
                        error_text = await response.text()
                        print(f"‚ùå Error Ollama Cloud: {response.status} - {error_text}")
                        return ""
        except Exception as e:
            print(f"‚ùå Error llamando a Ollama Cloud: {e}")
            return ""

    async def get_product_description(self, product_name: str) -> str:
        return f"Descripci√≥n de {product_name}"

    async def get_product_recommendations(self, product_description: str, num_recommendations: int = 3) -> List[str]:
        return [f"Recomendaci√≥n {i+1}" for i in range(num_recommendations)]

    async def ask_ai(self, prompt: str, system_prompt: str = None) -> str:
        """
        M√©todo p√∫blico para hacer consultas directas a la IA.
        """
        return await self._call_perplexity_cloud(prompt, system_prompt)

    async def search_con_ia(self, query: str, context: str = None, use_cloud: bool = True) -> dict:
        """
        B√∫squeda usando Ollama Cloud - Devuelve JSON estructurado.
        """
        try:
            # Verificar conexi√≥n primero
            if not await self.test_connection():
                print("‚ùå Ollama Cloud no est√° disponible. Usando respuesta de fallback.")
                return self._fallback_response(query)
            
            # Prompt para Ollama Cloud
            system_prompt = """Eres un asistente experto en bienes ra√≠ces. Tu tarea es extraer criterios de b√∫squeda de consultas de usuarios y responder √öNICAMENTE con un JSON v√°lido que contenga los criterios encontrados.

FORMATO DE RESPUESTA OBLIGATORIO:
{
    "tipo": "departamento|casa|local|terreno|null",
    "precio_min": numero o null,
    "precio_max": numero o null,
    "habitaciones": numero o null,
    "banos": numero o null,
    "area_min": numero o null,
    "area_max": numero o null,
    "ubicacion": "texto o null",
    "otros": "criterios adicionales o null"
}

REGLAS IMPORTANTES:
- Responde SOLO con JSON, sin texto adicional
- Usa null para criterios no mencionados
- Precios en n√∫meros sin formato (ej: 250000 no "250,000")
- Para rangos, usa min y max
- Para valores exactos, usa solo uno de los campos"""

            user_prompt = f"""Extrae los criterios de b√∫squeda de esta consulta:
"{query}"

Responde √∫nicamente con el JSON de criterios:"""

            print(f"‚òÅÔ∏è Enviando a Ollama Cloud (modelo Perplexity): {query}")
            
            # Llamar a Ollama Cloud con modelo Perplexity
            response = await self._call_perplexity_cloud(user_prompt, system_prompt)
            
            if response:
                print(f"‚òÅÔ∏è Respuesta de Ollama Cloud (Perplexity): {response}")
                # Devolver con clave 'response' para compatibilidad con el pipeline IA
                return {"response": response, "respuesta": response}
            else:
                print("‚ùå No se recibi√≥ respuesta de Ollama Cloud")
                return self._fallback_response(query)
                
        except Exception as e:
            print(f"‚ùå Error en search_con_ia: {e}")
            return self._fallback_response(query)

    def _fallback_response(self, consulta: str) -> dict:
        """Respuesta de fallback cuando Ollama no est√° disponible."""
        # Extraer criterios usando heur√≠sticas simples
        criterios = {}
        
        # Tipo de propiedad
        if "departamento" in consulta.lower():
            criterios["tipo"] = "departamento"
        elif "casa" in consulta.lower():
            criterios["tipo"] = "casa"
        elif "local" in consulta.lower():
            criterios["tipo"] = "local"
        elif "terreno" in consulta.lower():
            criterios["tipo"] = "terreno"
        
        # Habitaciones
        hab_match = re.search(r'(\d+)\s*(?:habitacion|dormitor|cuarto)', consulta.lower())
        if hab_match:
            criterios["habitaciones"] = int(hab_match.group(1))
        
        # Ba√±os
        bano_match = re.search(r'(\d+)\s*ba[√±n]o', consulta.lower())
        if bano_match:
            criterios["banos"] = int(bano_match.group(1))
        
        # √Årea
        area_match = re.search(r'(\d+)\s*(?:m2|metro|metro cuadrado)', consulta.lower())
        if area_match:
            criterios["area_min"] = int(area_match.group(1))
        
        # Precio
        precio_match = re.search(r'(\d+(?:,\d{3})*)\s*(?:peso|dollar|\$)', consulta.lower())
        if precio_match:
            precio = int(precio_match.group(1).replace(',', ''))
            criterios["precio_max"] = precio
        
        json_response = json.dumps(criterios, ensure_ascii=False)
        print(f"üîÑ Respuesta fallback: {json_response}")
        
        # Devolver 'response' para mantener compatibilidad con otros m√©todos
        return {"response": json_response, "respuesta": json_response}
    
    async def search_ia_real_state(self, query: str, use_cloud: bool = True) -> dict:
        """
        B√∫squeda de propiedades 100% con IA - Todo el procesamiento delegado a la IA.
        """
        print(f"üîç B√∫squeda 100% IA: {query}")
        
        # Cargar todas las propiedades del JSON
        all_properties = self._load_properties_json()
        
        if not all_properties:
            return {
                "properties": [],
                "keywords": [],
                "analysis": "No hay propiedades disponibles.",
                "metadata": {"total_properties": 0, "ai_used": True}
            }
        
        # Delegar TODO a la IA usando nuestros m√©todos especializados
        try:
            # 1. IA extrae criterios
            print(f"üìù Paso 1: Extrayendo criterios de: '{query}'")
            criteria = await self._parse_query_with_ia(query)
            print(f"üìã Criterios extra√≠dos: {criteria}")
            keywords = criteria.get('keywords', [])
            
            # 2. IA filtra propiedades
            print(f"üîç Paso 2: Filtrando {len(all_properties)} propiedades con criterios: {criteria}")
            filtered_properties = await self._filter_properties_with_ia(all_properties, criteria, query)
            print(f"‚úÖ Propiedades filtradas: {len(filtered_properties)}")
            
            # 3. IA genera an√°lisis
            print(f"üìù Paso 3: Generando an√°lisis para {len(filtered_properties)} propiedades")
            analysis = await self._generate_analysis_with_ia(filtered_properties, criteria, query)
            
            return {
                "success": True,
                "properties": [
                    {
                        "id": prop["id"],
                        "titulo": prop["titulo"],
                        "descripcion": prop["descripcion"],
                        "tipo": prop["tipo"],
                        "precio": prop["precio"],
                        "habitaciones": prop["habitaciones"],
                        "banos": prop["banos"],
                        "area_m2": prop["area_m2"],
                        "ubicacion": prop["ubicacion"],
                        "fecha_publicacion": prop["fecha_publicacion"],
                        "imagen_url": prop["imagen_url"]
                    } for prop in filtered_properties
                ],
                "total_found": len(filtered_properties),
                "keywords": keywords[:3],
                "analysis": analysis,
                "criteria_applied": criteria,
                "metadata": {
                    "ai_used": True,
                    "model_used": "full_ai_pipeline",
                    "total_properties_analyzed": len(all_properties),
                    "filtered_properties": len(filtered_properties),
                    "exact_match": True,
                    "timestamp": datetime.now().isoformat()
                }
            }
            
        except Exception as e:
            print(f"Error en pipeline IA: {e}")
            # Si todo falla, devolver respuesta b√°sica con estructura JSON consistente
            return {
                "success": False,
                "properties": [],
                "total_found": 0,
                "keywords": [word for word in query.split() if len(word) > 3][:3],
                "analysis": "Lo siento, no pude procesar tu consulta correctamente. Por favor intenta reformular tu b√∫squeda.",
                "criteria_applied": {},
                "metadata": {
                    "ai_used": False,
                    "error": str(e),
                    "total_properties_analyzed": len(all_properties),
                    "filtered_properties": 0,
                    "exact_match": False,
                    "timestamp": datetime.now().isoformat()
                }
            }
    
    async def _fallback_heuristics(self, query: str, all_properties: list) -> dict:
        """
        M√©todo de respaldo usando IA para extraer criterios si el procesamiento principal falla.
        """
        print("‚ö†Ô∏è  Procesamiento principal fall√≥, usando IA para extraer criterios")
        
        # Usar IA para extraer criterios
        criteria = await self._parse_query_with_ia(query)
        keywords = criteria.get('keywords', [])
        
        # Usar IA para filtrar propiedades
        filtered_properties = await self._filter_properties_with_ia(all_properties, criteria, query)
        
        # Usar IA para generar an√°lisis
        analysis = await self._generate_analysis_with_ia(filtered_properties, criteria, query)
        
        return {
            "success": True,
            "properties": [
                {
                    "id": prop["id"],
                    "titulo": prop["titulo"],
                    "descripcion": prop["descripcion"],
                    "tipo": prop["tipo"],
                    "precio": prop["precio"],
                    "habitaciones": prop["habitaciones"],
                    "banos": prop["banos"],
                    "area_m2": prop["area_m2"],
                    "ubicacion": prop["ubicacion"],
                    "fecha_publicacion": prop["fecha_publicacion"],
                    "imagen_url": prop["imagen_url"]
                } for prop in filtered_properties
            ],
            "total_found": len(filtered_properties),
            "keywords": keywords[:3],
            "analysis": f"[Modo respaldo IA] {analysis}",
            "criteria_applied": criteria,
            "metadata": {
                "ai_used": True,
                "fallback_mode": True,
                "total_properties_analyzed": len(all_properties),
                "filtered_properties": len(filtered_properties),
                "exact_match": True,
                "timestamp": datetime.now().isoformat()
            }
        }
    
    async def _parse_query_with_ia(self, query: str) -> dict:
        """
        Usar IA para extraer criterios de la consulta del cliente.
        """
        
        # Crear prompt para que la IA extraiga criterios
        criteria_prompt = f"""
        CONSULTA DEL CLIENTE: "{query}"
        
        INSTRUCCIONES:
        Analiza la consulta y extrae √öNICAMENTE los criterios de b√∫squeda espec√≠ficos.
        
        CRITERIOS POSIBLES:
        - ubicacion: zona espec√≠fica (ej: "zona 1", "zona 2", "centro", etc.)
        - precio_min: precio m√≠nimo en n√∫meros
        - precio_max: precio m√°ximo en n√∫meros
        - habitaciones: n√∫mero exacto de habitaciones
        - banos: n√∫mero exacto de ba√±os
        - banos_min: n√∫mero m√≠nimo de ba√±os (para "m√°s de X" usa X+0.1)
        - area_min: metros cuadrados m√≠nimos
        - area_max: metros cuadrados m√°ximos
        - tipo: "casa", "apartamento", "departamento", "terreno"
        - keywords: palabras clave relevantes
        
        REGLAS ESPECIALES:
        - "m√°s de 2 ba√±os" = banos_min: 2.1
        - "al menos 2 ba√±os" = banos_min: 2
        - N√∫meros grandes (>50) sin contexto = √°rea en m¬≤
        - "hasta $200,000" = precio_max: 200000
        
        RESPONDE CON UN JSON:
        {{
            "ubicacion": "valor o null",
            "precio_min": n√∫mero o null,
            "precio_max": n√∫mero o null,
            "habitaciones": n√∫mero o null,
            "banos": n√∫mero o null,
            "banos_min": n√∫mero o null,
            "area_min": n√∫mero o null,
            "area_max": n√∫mero o null,
            "tipo": "valor o null",
            "keywords": ["palabra1", "palabra2", "palabra3"]
        }}
        """
        
        # Llamar a la IA para extraer criterios
        ia_result = await self.search_con_ia(criteria_prompt, "", True)
        ai_response = ia_result.get("response", "")
        
        print(f"ü§ñ Respuesta IA para criterios: '{ai_response[:200]}...'")
        
        try:
            # Intentar extraer JSON de la respuesta
            json_start = ai_response.find('{')
            json_end = ai_response.rfind('}') + 1
            
            print(f"üìç JSON encontrado en posiciones: {json_start} a {json_end}")
            
            if json_start >= 0 and json_end > json_start:
                json_str = ai_response[json_start:json_end]
                print(f"üìÑ JSON extra√≠do: {json_str}")
                criteria = json.loads(json_str)
                
                # Limpiar valores null
                clean_criteria = {}
                for key, value in criteria.items():
                    if value is not None and value != "null" and value != "":
                        clean_criteria[key] = value
                
                return clean_criteria
            else:
                raise ValueError("No se encontr√≥ JSON v√°lido")
                
        except Exception as e:
            print(f"‚ùå Error extrayendo criterios con IA: {e}")
            print(f"üìÑ Respuesta completa de IA: {ai_response}")
            # Fallback b√°sico: extraer palabras clave
            fallback_criteria = {
                "keywords": [word for word in query.split() if len(word) > 3][:3]
            }
            print(f"üîÑ Usando criterios fallback: {fallback_criteria}")
            return fallback_criteria
    
    async def _filter_properties_with_ia(self, all_properties: list, criteria: dict, original_query: str) -> list:
        """
        Usar IA para filtrar propiedades seg√∫n criterios extra√≠dos - SIN expresiones regulares.
        """
        
        # Preparar contexto con propiedades numeradas para la IA
        properties_context = "PROPIEDADES DISPONIBLES:\n"
        for i, prop in enumerate(all_properties, 1):
            properties_context += f"{i}. {prop['titulo']} - "
            properties_context += f"Tipo: {prop['tipo']}, Precio: ${prop['precio']:,.0f}, "
            properties_context += f"Habitaciones: {prop['habitaciones']}, Ba√±os: {prop['banos']}, "
            properties_context += f"√Årea: {prop['area_m2']} m¬≤, Ubicaci√≥n: {prop['ubicacion']}\n"
        
        # Crear prompt ESTRICTO para coincidencias exactas
        filter_prompt = f"""
        CONSULTA ORIGINAL: "{original_query}"
        CRITERIOS EXTRA√çDOS: {json.dumps(criteria, ensure_ascii=False)}
        
        {properties_context}
        
        INSTRUCCIONES ESTRICTAS - FILTRADO EXACTO:
        1. TIPO: Si se especifica tipo, debe coincidir EXACTAMENTE
           - "departamento" = solo departamentos
           - "casa" = solo casas  
           - "terreno" = solo terrenos
        
        2. PRECIO: Si se especifica precio, debe ser EXACTO
           - precio: 280000 = SOLO propiedades de $280,000
           - precio_min: 200000 = propiedades >= $200,000
           - precio_max: 300000 = propiedades <= $300,000
        
        3. HABITACIONES: Si se especifica, debe ser EXACTO
           - habitaciones: 2 = SOLO propiedades con 2 habitaciones
        
        4. BA√ëOS: Si se especifica, debe ser EXACTO
           - banos: 2 = SOLO propiedades con 2 ba√±os
           - banos_min: 2.1 = propiedades con M√ÅS de 2 ba√±os (2.5, 3, etc.)
        
        5. √ÅREA: Si se especifica, debe ser EXACTA o dentro del rango
           - area_m2: 120 = SOLO propiedades de 120 m¬≤
           - area_min: 120 = propiedades >= 120 m¬≤
           - area_max: 120 = propiedades <= 120 m¬≤
        
        6. UBICACI√ìN: Si se especifica, debe contener la palabra/zona exacta
        
        REGLAS DE FILTRADO:
        - TODOS los criterios deben cumplirse simult√°neamente
        - NO busques "similares" o "cercanos"
        - Si NO hay coincidencias exactas, devuelve "ninguna"
        - M√°ximo 5 propiedades que cumplan TODOS los criterios
        
        RESPONDE √öNICAMENTE CON:
        Los N√öMEROS de las propiedades que cumplen EXACTAMENTE todos los criterios, separados por comas.
        Ejemplo: "1, 3, 7"
        
        Si NO hay coincidencias exactas, responde: "ninguna"
        NO agregues texto adicional, solo los n√∫meros o "ninguna".
        """
        
        # Llamar a la IA
        ia_result = await self.search_con_ia(filter_prompt, properties_context, True)
        ai_response = ia_result.get("response", "").strip().lower()
        
        print(f"ü§ñ Respuesta IA para filtrado: '{ai_response}'")
        print(f"üìä Criterios para filtrado: {criteria}")
        
        # Procesar respuesta de la IA para extraer n√∫meros
        selected_properties = []
        try:
            if "ninguna" in ai_response or "no hay" in ai_response:
                print("‚úÖ IA determin√≥ que no hay coincidencias exactas")
                return []
            
            # La IA deber√≠a devolver algo como "1, 3, 7"
            numbers_str = ai_response.replace("n√∫meros:", "").replace("propiedades:", "").strip()
            
            # Extraer n√∫meros de la respuesta
            numbers = []
            for part in numbers_str.split(','):
                try:
                    num = int(part.strip())
                    if 1 <= num <= len(all_properties):  # N√∫mero v√°lido
                        numbers.append(num)
                except:
                    continue
            
            # Convertir n√∫meros a propiedades (√≠ndice base-1)
            for num in numbers[:5]:  # M√°ximo 5
                if num <= len(all_properties):
                    selected_properties.append(all_properties[num - 1])  # Convertir a √≠ndice base-0
            
            print(f"‚úÖ IA seleccion√≥ propiedades EXACTAS: {numbers[:5]}")
            
        except Exception as e:
            print(f"Error procesando n√∫meros de la IA: {e}")
            print(f"Respuesta de IA: {ai_response}")
        
        # Validar que las propiedades seleccionadas realmente cumplan los criterios exactos
        validated_properties = []
        for prop in selected_properties:
            if self._validate_exact_criteria(prop, criteria):
                validated_properties.append(prop)
            else:
                print(f"‚ö†Ô∏è  Propiedad {prop['titulo']} no cumple criterios exactos, exclu√≠da")
        
        return validated_properties
    
    def _validate_exact_criteria(self, prop: dict, criteria: dict) -> bool:
        """
        Validar que una propiedad cumple EXACTAMENTE con los criterios.
        """
        
        # Validar tipo exacto
        if criteria.get('tipo'):
            if prop.get('tipo', '').lower() != criteria['tipo'].lower():
                return False
        
        # Validar precio exacto
        if criteria.get('precio'):
            if prop.get('precio', 0) != criteria['precio']:
                return False
        
        # Validar precio m√≠nimo y m√°ximo
        if criteria.get('precio_min'):
            if prop.get('precio', 0) < criteria['precio_min']:
                return False
        
        if criteria.get('precio_max'):
            if prop.get('precio', 0) > criteria['precio_max']:
                return False
        
        # Validar habitaciones exactas
        if criteria.get('habitaciones'):
            if prop.get('habitaciones', 0) != criteria['habitaciones']:
                return False
        
        # Validar ba√±os exactos
        if criteria.get('banos'):
            if prop.get('banos', 0) != criteria['banos']:
                return False
        
        # Validar ba√±os m√≠nimos (m√°s de X)
        if criteria.get('banos_min'):
            if prop.get('banos', 0) < criteria['banos_min']:
                return False
        
        # Validar √°rea exacta
        if criteria.get('area_m2'):
            if prop.get('area_m2', 0) != criteria['area_m2']:
                return False
        
        # Validar √°rea m√≠nima y m√°xima
        if criteria.get('area_min'):
            if prop.get('area_m2', 0) < criteria['area_min']:
                return False
        
        if criteria.get('area_max'):
            if prop.get('area_m2', 0) > criteria['area_max']:
                return False
        
        # Validar ubicaci√≥n (debe contener la zona/palabra)
        if criteria.get('ubicacion'):
            ubicacion_prop = (prop.get('ubicacion') or '').lower()
            ubicacion_busqueda = str(criteria.get('ubicacion')).lower()
            if ubicacion_busqueda not in ubicacion_prop:
                return False
        
        return True
    
    async def _generate_analysis_with_ia(self, filtered_properties: list, criteria: dict, original_query: str) -> str:
        """
        Usar IA para generar respuesta conversacional y natural.
        """
        
        if not filtered_properties:
            # Prompt para respuesta cuando NO hay resultados
            system_prompt = """Eres un asistente experto en bienes ra√≠ces muy amigable y profesional. 
Tu cliente te hizo una consulta pero no encontraste propiedades que coincidan exactamente.
Responde de forma natural, emp√°tica y ofrece alternativas o sugerencias √∫tiles."""

            user_prompt = f"""El cliente pregunt√≥: "{original_query}"

No encontr√© propiedades que coincidan exactamente con esos criterios.

Genera una respuesta conversacional y √∫til que:
1. Sea emp√°tica y profesional
2. Explique brevemente por qu√© no hay resultados
3. Sugiera alternativas (modificar presupuesto, zona, caracter√≠sticas, etc.)
4. Mantenga un tono amigable y motivador
5. Sea concisa (m√°ximo 3-4 oraciones)

Responde directamente como si hablaras con el cliente:"""
        else:
            # Prompt para respuesta cuando S√ç hay resultados
            properties_detail = []
            for i, prop in enumerate(filtered_properties[:5], 1):  # M√°ximo 5 propiedades
                properties_detail.append(
                    f"{i}. {prop['titulo']}\n"
                    f"   - Precio: ${prop['precio']:,.0f}\n"
                    f"   - {prop['habitaciones']} habitaciones, {prop['banos']} ba√±os\n"
                    f"   - {prop['area_m2']} m¬≤\n"
                    f"   - Ubicaci√≥n: {prop['ubicacion']}"
                )
            
            system_prompt = """Eres un asistente experto en bienes ra√≠ces muy amigable y profesional.
Ayudas a los clientes presentando las propiedades de forma atractiva y √∫til.
Usa un lenguaje natural y conversacional, como si hablaras cara a cara."""

            user_prompt = f"""El cliente pregunt√≥: "{original_query}"

Encontr√© {len(filtered_properties)} propiedad(es) que coincide(n):

{chr(10).join(properties_detail)}

Genera una respuesta conversacional que:
1. Confirme qu√© encontraste de forma entusiasta
2. Destaque las caracter√≠sticas m√°s relevantes seg√∫n la consulta original
3. Mencione brevemente cada propiedad de forma atractiva
4. Invite al cliente a conocer m√°s detalles
5. Sea profesional pero cercana y amigable
6. M√°ximo 4-5 oraciones

Responde directamente como si hablaras con el cliente:"""
        
        # Llamar a la IA con el nuevo formato conversacional
        print(f"üí¨ Generando respuesta conversacional de IA...")
        response = await self._call_perplexity_cloud(user_prompt, system_prompt)
        
        if response and len(response.strip()) > 20:
            print(f"‚úÖ Respuesta IA generada: {response[:100]}...")
            return response.strip()
        else:
            # Fallback si la IA no responde
            if filtered_properties:
                return f"Encontr√© {len(filtered_properties)} propiedad(es) que coinciden con tu b√∫squeda. Te muestro las opciones disponibles."
            else:
                return "No encontr√© propiedades que coincidan exactamente con esos criterios. ¬øTe gustar√≠a que busque con criterios m√°s flexibles?"
    
    def _format_json_response(self, properties: list, criteria: dict, analysis: str, keywords: list, 
                            total_analyzed: int, success: bool = True, error: str = None) -> dict:
        """
        Formatear respuesta en JSON estructurado y consistente.
        """
        response = {
            "success": success,
            "properties": [
                {
                    "id": prop.get("id"),
                    "titulo": prop.get("titulo", ""),
                    "descripcion": prop.get("descripcion", ""),
                    "tipo": prop.get("tipo", ""),
                    "precio": float(prop.get("precio", 0)),
                    "habitaciones": int(prop.get("habitaciones", 0)),
                    "banos": float(prop.get("banos", 0)),
                    "area_m2": float(prop.get("area_m2", 0)),
                    "ubicacion": prop.get("ubicacion", ""),
                    "fecha_publicacion": prop.get("fecha_publicacion"),
                    "imagen_url": prop.get("imagen_url", "")
                } for prop in properties
            ],
            "total_found": len(properties),
            "keywords": keywords[:3] if keywords else [],
            "analysis": analysis or "B√∫squeda completada",
            "criteria_applied": criteria or {},
            "metadata": {
                "ai_used": True,
                "total_properties_analyzed": total_analyzed,
                "filtered_properties": len(properties),
                "exact_match": True,
                "timestamp": datetime.now().isoformat()
            }
        }
        
        if error:
            response["metadata"]["error"] = error
            response["metadata"]["ai_used"] = False
            response["metadata"]["exact_match"] = False
        
        return response
    
    def _load_properties_json(self) -> list:
        """Cargar todas las propiedades del JSON para procesamiento con IA."""
        try:
            json_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'data', 'products.json')
            with open(json_path, 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            
            properties = []
            for item in json_data:  # Cargar TODAS las propiedades para la IA
                try:
                    properties.append({
                        'id': item.get('id'),
                        'titulo': item.get('titulo', ''),
                        'descripcion': item.get('descripcion', ''),
                        'tipo': item.get('tipo', ''),
                        'precio': float(item.get('precio', 0) or 0),
                        'habitaciones': int(item.get('habitaciones', 0) or 0),
                        'banos': float(item.get('banos', 0) or 0),
                        'area_m2': float(item.get('area_m2', 0) or 0),
                        'ubicacion': item.get('ubicacion', ''),
                        'fecha_publicacion': item.get('fecha_publicacion'),
                        'imagen_url': item.get('imagen_url', '')
                    })
                except:
                    continue
            
            print(f"üìä Cargadas {len(properties)} propiedades para an√°lisis con IA")
            return properties
            
        except Exception as e:
            print(f"Error cargando JSON: {e}")
            return []